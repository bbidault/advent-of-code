# https://adventofcode.com/2025/day/10

import itertools
import numpy as np
import re
from scipy.optimize import milp, LinearConstraint, Bounds


## Checks whether a given set of buttons presses leads to the given set of lights configuration.
#
# @param lights: a lights configuration.
# @param buttons: a set of buttons to press.
# @return whether a given set of buttons presses leads to the given set of lights configuration.
#
def isValid(lights: str, buttons: list) -> bool:
    # generate a light configuration by pressing buttons.
    resultingLights = [0] * len(lights)
    for button in buttons:
        for press in button:
            resultingLights[int(press)] += 1
    # "draw" the light configuration generated by pressing the buttons.
    result = ""
    for rLight in resultingLights:
        if rLight % 2 == 0:
            result += "."
        else:
            result += "#"
    # compare the desired light configuration with the generated one.
    return result == lights


## Compute the minimum number of buttons to press to get the given lights configuration.
#
# @param lights: a lights configuration.
# @param buttons: a set of buttons available to press.
# @return the minimum number of buttons to press.
#
def findCombination(lights: str, buttons: list) -> int:
    for num in range(1, len(buttons)):
        # try all the configurations of "num" buttons out of all the buttons.
        combinations = list(itertools.combinations(buttons, num))
        for combination in combinations:
            if isValid(lights, combination):
                return num


## Use scipy "mixed integer linear programming" function to solve the system of
#  equations Ax = b with A the buttons and b the joltages.
#
# @param joltages: a list of joltage levels to achieve by pressing buttons.
# @param buttons: a list of buttons to press to increase joltage levels.
# @return the number of buttons presses necessary to get the given joltages configuration.
#
def mixedIntegerLinearProgramming(joltages: list, buttons: list) -> int:
    # Build matrix A: A[j][i] = 1 if button i affects output j
    A = np.zeros((len(joltages), len(buttons)))
    for i, button in enumerate(buttons):
        for j in button:
            A[j][i] = 1

    b = np.array(joltages)

    # Minimize sum(x) subject to Ax = b, x >= 0, x integer
    c = np.ones(len(buttons))  # minimize sum of x
    constraints = LinearConstraint(A, b, b)  # Ax = b
    bounds = Bounds(lb=0, ub=np.inf)
    integrality = np.ones(len(buttons))

    result = milp(c, constraints=constraints, bounds=bounds, integrality=integrality)

    # return the optimal value of the objective function.
    return int(result.fun)


## Compute and return the number of buttons presses necessary to get the desired lights
#  configuration and joltage levels.
#
# @param inputFilePath: the input file
# @return the number of buttons presses necessary to get the desired lights configuration
#         and joltage levels.
#
def compute(inputFilePath: str) -> tuple:
    inputFile = open(inputFilePath, "r")
    lines = inputFile.readlines()
    inputFile.close()

    part1 = 0
    part2 = 0
    for line in lines:
        lights = re.findall(r"\[(.*?)\]", line)[0]
        buttonsStr = re.findall(r"\((.*?)\)", line)
        joltages = re.findall(r"\{(.*?)\}", line)[0]

        buttons = [list(map(int, str.split(","))) for str in buttonsStr]

        part1 += findCombination(lights, buttons)
        part2 += mixedIntegerLinearProgramming(joltages.split(","), buttons)

    return (part1, part2)


part1Test, part2Test = compute("test_input.txt")
part1, part2 = compute("input.txt")
print("Part 1 test:", part1Test)
print("Part 1 solution:", part1)
print("Part 2 test:", part2Test)
print("Part 2 solution:", part2)
